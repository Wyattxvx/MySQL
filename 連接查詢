/* 練習1 */
Customers table:
+----+-------+
| id | name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
Orders table:
+----+------------+
| id | customerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
Write an SQL query to report all customers who never order anything.
Return the result table in any order.

SELECT name as Customers
FROM customers c LEFT JOIN orders o ON c.id=o.customerID
WHERE o.customerId is null
--------------------------------------------------------------------------
/* 練習2 */
Person table:
+----------+----------+-----------+
| personId | lastName | firstName |
+----------+----------+-----------+
| 1        | Wang     | Allen     |
| 2        | Alice    | Bob       |
+----------+----------+-----------+
Address table:
+-----------+----------+---------------+------------+
| addressId | personId | city          | state      |
+-----------+----------+---------------+------------+
| 1         | 2        | New York City | New York   |
| 2         | 3        | Leetcode      | California |
+-----------+----------+---------------+------------+
Write an SQL query to report the first name, last name, city, and state of each person in the Person table. 
If the address of a personId is not present in the Address table, report null instead.
Return the result table in any order.

SELECT firstname, lastname, city, state
FROM person p LEFT JOIN address a ON p.personid=a.personid
--------------------------------------------------------------------------
/* 練習3 連接並分組排序*/
Visits
+----------+-------------+
| visit_id | customer_id |
+----------+-------------+
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |
+----------+-------------+
Transactions
+----------------+----------+--------+
| transaction_id | visit_id | amount |
+----------------+----------+--------+
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |
+----------------+----------+--------+
Write a SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.
Return the result table sorted in any order.

SELECT v.customer_id,count(v.customer_id)as count_no_trans
FROM visits v LEFT JOIN transactions t USING(visit_id)
WHERE t.visit_id is null
GROUP BY v.customer_id
ORDER BY count_no_trans desc
#DATEDIFF的使用
--------------------------------------------------------------------------
/* 練習4 DATEDIFF的使用*/
Weather table:
+----+------------+-------------+
| id | recordDate | temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
Write an SQL query to find all dates'Id with higher temperatures compared to its previous dates (yesterday).
Return the result table in any order.

SELECT w1.id
FROM weather w1,weather w2
WHERE w1.temperature>w2.temperature and datediff(w1.recordDate,w2.recordDate)=1
#以w1當今天，w2當昨天，用DATEDIFF相減=1表示相差一天
--------------------------------------------------------------------------
/* 練習5 分組後用HAVING篩選 */
Users table:
+------------+--------------+
| account    | name         |
+------------+--------------+
| 900001     | Alice        |
| 900002     | Bob          |
| 900003     | Charlie      |
+------------+--------------+
Transactions table:
+------------+------------+------------+---------------+
| trans_id   | account    | amount     | transacted_on |
+------------+------------+------------+---------------+
| 1          | 900001     | 7000       |  2020-08-01   |
| 2          | 900001     | 7000       |  2020-09-01   |
| 3          | 900001     | -3000      |  2020-09-02   |
| 4          | 900002     | 1000       |  2020-09-12   |
| 5          | 900003     | 6000       |  2020-08-07   |
| 6          | 900003     | 6000       |  2020-09-07   |
| 7          | 900003     | -4000      |  2020-09-11   |
+------------+------------+------------+---------------+
Write an SQL query to report the name and balance of users with a balance higher than 10000. 
The balance of an account is equal to the sum of the amounts of all transactions involving that account.
Return the result table in any order.

SELECT name,sum(amount)as balance
FROM users u LEFT JOIN transactions t USING(account)
GROUP BY account
HAVING SUM(amount)>10000
--------------------------------------------------------------------------
/* 練習6 用MIN和MAX限制日期範圍 */
Product table:
+------------+--------------+------------+
| product_id | product_name | unit_price |
+------------+--------------+------------+
| 1          | S8           | 1000       |
| 2          | G4           | 800        |
| 3          | iPhone       | 1400       |
+------------+--------------+------------+
Sales table:
+-----------+------------+----------+------------+----------+-------+
| seller_id | product_id | buyer_id | sale_date  | quantity | price |
+-----------+------------+----------+------------+----------+-------+
| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |
| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |
| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |
| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |
+-----------+------------+----------+------------+----------+-------+
Write an SQL query that reports the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.
Return the result table in any order.

SELECT p.product_id,p.product_name
FROM product p LEFT JOIN sales s USING(product_id)
GROUP BY p.product_id
HAVING MIN(sale_date)>='2019-01-01' and MAX(sale_date)<='2019-03-31'
